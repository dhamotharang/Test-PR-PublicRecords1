/*
	should remove any carriage returns, line feeds,maybe any binary characters
	trim fields
	if give separator, surround field with quotes if it contains separator character
	remove terminator characters from field(should be optional, just in case)
	if there is a quote character inside a field, should be escaped(by literal escape char(\), or by doubling up the char?)
separator
terminator
quote
	Should convert record to one field
	prepend the field names as first record
	trim fields
	handle separators/terminators/quotes inside fields?
	handle integers that need to be zero filled on left?  like zips?
*/
export mac_ConvertToCsv(

	 pDataset															// input dataset	-- needs to be fixed length record
	,pOutput															// Named output to run ecl generated by macro
	,pSeparator								= '\',\''
	,pTerminator							= '\'\\n\''
	,pQuote										= '\'"\''
	,pDatasetRecLength				= '100000'	// Length of input dataset record(can't do sizeof in macro)
																			// Default to 10,000 bytes, should work for most record sizes--only change
																			// if your input record length is larger
	,pOutputEcl								= 'false'	// Should output the ecl as a string(for testing) or actually run the ecl
	,pShouldExport						= 'true'	// should export output parameter(so can access outside of a module)
	
) :=
macro

	/*
		First, get the sizeof the record layout in the passed dataset
		then, project the input dataset to a one field layout that is the size of the whole dataset
		by looping through the fields and concatenating them into the one field
		Then, project that dataset into the new layout passed in
		by calculating the offsets of the one field dataset and taking those slices
		by looping through destination layout.
	*/

	/////////////////////////////////////////////
	// -- Start XML
	/////////////////////////////////////////////
	LOADXML('<xml/>');
	#EXPORTXML(pDataset_MetaInfo						,recordof(pDataset))

	/////////////////////////////////////////////
	// -- Declare Value Types
	/////////////////////////////////////////////
	#uniquename(name							)
	#uniquename(named_layout			)
	#uniquename(stringfiller			)
	#uniquename(lenName						)
	#uniquename(lenType						)
	#uniquename(fillername				)
	#uniquename(fillertype				)
	#uniquename(moutput						)
	#uniquename(loutput						)
	#uniquename(lsize							)
	#uniquename(lIsDataset				)
	#uniquename(SizeofDatasetRec	)
	#uniquename(dDataset					)
	#uniquename(lDataset					)
	#uniquename(Layout_pInput_Lengths)
	#uniquename(pInput_prep				)
	#uniquename(pInput_prep2			)
	#uniquename(childdatasetnum		)
	#uniquename(lcounter					)
	#uniquename(lcounter2					)
	#uniquename(lchildatasetfields)
	#uniquename(lchildatasetlengths)
	#uniquename(lnumchildatasetfields)
	#uniquename(lchildatasetfieldlength)
	#uniquename(lchilddatasetline)
	#uniquename(startindex				)
	#uniquename(endindex					)
	#uniquename(dummydataset			)
	#uniquename(dblank						)
	#uniquename(ddummy						)
	#uniquename(headerrec					)
	#uniquename(dheaderrec					)
	#uniquename(fseparator		)
	#uniquename(fcleanUpfield	)
	#uniquename(fcleanall			)
	#uniquename(fcleanUpfield	)
	#uniquename(fquote				)

	/////////////////////////////////////////////
	// -- Prep Stuff
	/////////////////////////////////////////////
	#SET(stringfiller, '                                                                           ')
//	#SET(SizeofDatasetRec	, sizeof(pDataset))
	#SET(named_layout	, '')
	#SET(name					, '')
	#SET(lIsDataset		, '')
	#SET(lchilddatasetline		, '')
	#SET(lchildatasetfields		, '')
	#SET(lchildatasetlengths		, '')
	#SET(lnumchildatasetfields	,1)
	#SET(lchildatasetfieldlength	,0)
	#SET(ldataset			,trim(#TEXT(pDataset),all))
	#SET(childdatasetnum	, 1)
	#if(pShouldExport = true)
		#SET(moutput	,'export ' + trim(#TEXT(pOutput),all))
	#ELSE
		#SET(moutput	,trim(#TEXT(pOutput),all))
	#END
	#IF(pOutputEcl = true)
		#SET(dDataset								,'pDataset')
		#SET(Layout_pInput_Lengths	,'Layout_pInput_Lengths')
		#SET(pInput_prep						,'pInput_prep')
		#SET(pInput_prep2						,'pInput_prep2')
		#SET(dblank									,'dblank')
		#SET(ddummy									,'ddummy')
		#SET(dheaderrec							,'dheaderrec')
		#SET(fseparator							,'fseparator'		)
		#SET(fcleanUpfield					,'fcleanUpfield')
		#SET(fcleanall							,'fcleanall'		)
		#SET(fcleanUpfield					,'fcleanUpfield')
		#SET(fquote									,'fquote'				)
	#END

	#SET(headerrec				,%'dheaderrec'% + ' := dataset([{\'')

	/////////////////////////////////////////////
	// -- First Project to one field layout
	/////////////////////////////////////////////
	#SET		(loutput	,%'dDataset'% + ' := ' + %'ldataset'% + ';\n')
	#APPEND(loutput	,%'fseparator'% + '		(string pfield, string pseparator	,string pquote) := if(regexfind(\'[\' + pseparator + \']\'		,trim(pfield,left,right),nocase)	,pquote + trim(pfield,left,right) + pquote, trim(pfield,left,right));\n')
//	#APPEND(loutput	,'fterminator		(string pfield, string pterminator							) := if(regexfind(pterminator		,pfield,nocase)	,regexreplace(pterminator		,trim(pfield,left,right),\'\'						,nocase), trim(pfield,left,right));\n')
	#APPEND(loutput	,%'fquote'% 			 + '	(string pfield, string pquote										) := if(regexfind(\'[\' + pquote + \' ]\'	,pfield,nocase)	,regexreplace(pquote				,trim(pfield,left,right),pquote + pquote,nocase), trim(pfield,left,right));\n')
	#APPEND(loutput	,%'fcleanUpfield'% + '	(string pfield																	) := if(regexfind(\'[^[:print:]]\',pfield,nocase)	,regexreplace(\'[^[:print:]]\',pfield									,\'\'						,nocase), trim(pfield,left,right));\n')
	#APPEND(loutput	,%'fcleanall'% + '			(string pfield,string pseparator,string pterminator, string pquote) :=\n')
	#APPEND(loutput	,%'fcleanUpfield'% + '(' + %'fseparator'% + '		(' + %'fquote'% + '(pfield,pquote),pseparator,pquote));\n')
	#APPEND	(loutput	,%'pInput_prep'% + ' := project(' + %'dDataset'% + ',transform({string payload{maxlength(' + pDatasetRecLength + ')}}, self.payload := \n');

	#FOR (pDataset_MetaInfo)
		#FOR (Field)
			#IF(%'@isRecord'% = '1' or %'@isDataset'% = '1')
				#SET(named_layout	, %'@name'%)
				#SET(lIsDataset		, %'@isDataset'%)
			#ELSE
				#IF(%'named_layout'% = %'@name'% and %'@type'% = '')
					#SET(named_layout	, '')
					#IF(%'lIsDataset'% = '1')
						#SET(lcounter	, 1)
						#LOOP
							#IF(%lcounter% > psetChildDatasetNumIn[%childdatasetnum%])
								#BREAK
							#ELSE
								#APPEND(loutput, regexreplace('@index@',%'lchildatasetfields'%,%'lcounter'%,nocase))
								#SET(lcounter	,%lcounter% + 1)
							#END
						#END
						#SET(childdatasetnum	,%childdatasetnum% + 1)
						#SET(lchildatasetfields, '')
						#SET(lchildatasetlengths,'')
						#SET(lnumchildatasetfields	,1)
					#END
					#SET(lIsDataset		, '')
				#ELSE
					#IF(%'named_layout'% != '' and %'lIsDataset'% = '')
						#SET(name, %'named_layout'% + '.' + %'@name'%)

					#ELSIF(%'named_layout'% != '' and %'lIsDataset'% = '1')
						#SET(name, %'named_layout'% + '[@index@].' + %'@name'%)
						#APPEND(lchildatasetfields, ' + left.' + %'name'% + '\n')

					#ELSE
						#SET(name			, %'@name'%)
					#END
					
					//actual work done here
					#IF(%'lIsDataset'% != '1')
						#IF(%'@position'% != '0')
							#APPEND(loutput, ' + ' + #TEXT(pSeparator) + ' + ')
							#APPEND(headerrec	, pSeparator)
						#END
						#APPEND(headerrec	, %'name'%)
						#IF(%'@type'% != 'string')
							#APPEND(loutput, ' ' + %'fcleanall'% + '((string)left.' + %'name'% + ',' + #TEXT(pSeparator) + ',' + #TEXT(pTerminator) + ',' + #TEXT(pQuote) + ')\n')
						#ELSE
							#APPEND(loutput, ' ' + %'fcleanall'% + '(        left.' + %'name'% + ',' + #TEXT(pSeparator) + ',' + #TEXT(pTerminator) + ',' + #TEXT(pQuote) + ')\n')
						#END
					#END

				#END
			#END
		#END
	#END
	#APPEND(headerrec	,'\'}],{string payload{maxlength(' + pDatasetRecLength + ')}});\n')
//	#APPEND(loutput, ' + ' + #TEXT(pTerminator) + ' ;\n));\n');
	#APPEND(loutput, '  ;\n));\n');

	#APPEND(loutput, %'moutput'% + ' := ' + %'dheaderrec'% + ' + ' + %'pInput_prep'% + ';\n');
	#APPEND(headerrec	,%'loutput'%)
	
	#if(pOutputEcl = true)
		pOutput := %'headerrec'%;
	#ELSE
		%headerrec%;
	#END

endmacro;
