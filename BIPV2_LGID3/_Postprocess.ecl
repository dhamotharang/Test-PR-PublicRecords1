import bipv2,tools,wk_ut,std,BIPV2_Files,BIPV2_Tools,bipv2_strata;

l_common  := BIPV2.CommonBase.Layout;
l_base    := BIPV2_Files.files_lgid3.Layout_LGID3;

last_lgid3_iter    := '~' + nothor(std.file.superfilecontents(BIPV2_Files.files_lgid3.FILE_BUILDING)[1].name);
before_restore_ds  := dataset(last_lgid3_iter,l_base,thor);

EXPORT _PostProcess(

   string              pversion          = bipv2.KeySuffix   
  ,dataset(l_common  ) pDatasetIn        = BIPV2_Files.files_hrchy.FILE_HRCY_BASE_LF_FULL_BUILDING 
  // ,string              pSuperfileIn      = BIPV2_Files.files_dotid().FILE_BASE  
  ,dataset(l_base    ) pDatasetOut       = before_restore_ds    
  ,boolean             pCopy2StorageThor = BIPV2_LGID3._Constants().copy2storagethor

) :=
function

  TheSeleStruct :=record
    pDatasetOut.seleid;
    maxSeleId := Max(group,pDatasetOut.OriginalSeleId);
    maxOrgId  := Max(group,pDatasetOut.OriginalOrgId);
  end;
  
  TheSeleTable0 :=table(pDatasetOut,TheSeleStruct,seleid,skew(0.9));
  
  //The above we get : pair of (seleid, originalseleid), possible results : (1000,1000), (500,1000), (444,0). 
  //The (1000,1000) means (a) 1000-cluster itself or (b) a leafnode of the 1000-sele cluster or (c) a leafnode of it joining some singletons 
  //whose lgid3 have greater value than 1000. The "normal" case.
  //The (500,1000)  means a leafnode of sele-1000 joined to some singleton whose lgid3 has a smaller value of 500 and the leafnode has been updated 
  //and a new 500-sele cluster generated. The 1000-sele cluster get splitted if this happens.
  //The (444,0) means (a) there is a singleton, or (b) there is a singleton-singleton join. Either way, we don't care of them.
  
  TheSeleTable1 := TheSeleTable0(maxSeleId>0); //Get rid of case (444,0) because we don't care.

//Try to get the smallest seleid for each maxSeleId (the OriginalSeleId):	
  SeleSmallStruct :=record
    TheSeleTable1.maxSeleId;
    SmallSeleID :=Min(group, TheSeleTable1.seleid);
  end;
  
  TheSeleTable2 :=table(TheSeleTable1, SeleSmallStruct,maxSeleId); 
  //The above get SmallSeleID for each maxSeleId (the OriginalSeleId). 
  //It tells OriginalSeleId actullay should be replaced by SmallSeleID in the original structure as well as any singletons which join to the leafnodes.
  
//As the first step, we merge the new sele clusters that are generated by leafnode-singleton joining back to the original sele that the leafnodes belong to:
//So, we temporarily use the OriginalSeleId as the seleid in this hierarchy structure. This will violate the ID consistency but can finish the merge.	
  dsNew :=join(pDatasetOut, TheSeleTable1, Left.seleid=Right.seleid, 
                  transform(l_base, self.seleid :=if(Left.seleid=Right.seleid, Right.maxSeleId, Left.seleid);
                                    self.orgid  :=if(Left.seleid=Right.seleid, Right.maxOrgId, Left.orgid);
                                    self.ultid  :=if(Left.seleid=Right.seleid, Right.maxOrgId, Left.ultid);
                                    self        :=Left),LEFT OUTER, HASH);
                                    
//As the second step, we correct the ID inconsistency in the above hrchy structure using SmallSeleID:
  dsNew1 :=join(dsNew, TheSeleTable2, Left.seleid=Right.maxSeleId, 
                  transform(l_base, self.seleid :=if(Left.seleid=Right.maxSeleId, Right.SmallSeleID, Left.seleid);
                                    //self.orgid  :=if(Left.seleid=Right.maxSeleId, Right.SmallSeleID, Left.orgid);
                                    //self.ultid  :=if(Left.seleid=Right.maxSeleId, Right.SmallSeleID, Left.ultid);
                                    self        :=Left),LEFT OUTER, HASH);
                                    
                                    
//If in dsNew1 the orgid > the samllest seleid in the org cluster, then the whole org need to update to keep the ID consistency
    TheSeleTable3 :=dedup(sort(table(dsNew1(nodes_total>1), {seleid, orgid}),orgid,seleid),orgid,seleid);
    f_rec :=record
      TheSeleTable3.orgid;
      minSele :=min(group, TheSeleTable3.seleid);
    end;
    TheSeleTable4 := table(TheSeleTable3(orgid>0, seleid>0),f_rec,orgid);
    TheSeleTable5 :=TheSeleTable4(orgid>minSele);
  
  dsNew2 :=join(dsNew1, TheSeleTable5, Left.orgid=Right.orgid, 
                  transform(l_base, self.orgid  :=if(Left.orgid=Right.orgid, Right.minSele, Left.orgid);
                                    self.ultid  :=if(Left.orgid=Right.orgid, Right.minSele, Left.ultid);
                                    self        :=Left),LEFT OUTER, HASH);
    
//----end of merge-------------------------------
  //dsNew2:=dsNew1;
  
  ds_leafNodes :=dedup(sort(dsNew2(nodes_below_st ='0' and Lgid3IfHrchy <>''),lgid3,SKEW(1,0.5)),lgid3);
  l_base tr(l_base L, l_base R) :=transform
    self.has_lgid 				:=if(R.lgid3=L.lgid3, R.has_lgid, L.has_lgid);
    self.is_sele_level		:=if(R.lgid3=L.lgid3, R.is_sele_level, L.is_sele_level);
    self.is_org_level			:=if(R.lgid3=L.lgid3, R.is_org_level, L.is_org_level);
    self.is_ult_level			:=if(R.lgid3=L.lgid3, R.is_ult_level, L.is_ult_level);
    self.parent_proxid		:=if(R.lgid3=L.lgid3, R.parent_proxid, L.parent_proxid);
    self.sele_proxid			:=if(R.lgid3=L.lgid3, R.sele_proxid, L.sele_proxid);
    self.org_proxid				:=if(R.lgid3=L.lgid3, R.org_proxid, L.org_proxid);
    self.ultimate_proxid	:=if(R.lgid3=L.lgid3, R.ultimate_proxid, L.ultimate_proxid);
    self.levels_from_top	:=if(R.lgid3=L.lgid3, R.levels_from_top, L.levels_from_top);
    self.nodes_total			:=if(R.lgid3=L.lgid3, R.nodes_total, L.nodes_total); //not accurate but just used to distinquish zero and non-zero
    self:=L;
  end;
  //j1:=join(ds,ds_leafNodes,Left.lgid3=right.lgid3, tr(left, right), Left Outer,HASH);
  j1:=join(dsNew2,ds_leafNodes,Left.lgid3=right.lgid3, tr(left, right), Left Outer,HASH);
  // Restore the fields we selectively blanked during init
  l_common toRestore(l_base L, l_common R) := TRANSFORM
    SELF.company_name	  := R.company_name   ;
    SELF.cnp_number		  := R.cnp_number     ;
    self.duns_number    := R.duns_number    ;
    self.company_fein   := R.company_fein   ;
    SELF                := L; // pick up any changes from linking
    SELF                := R; // then re-widen back to the common layout
  END;
  
  //ds_restore := JOIN(ds, ds_common, LEFT.rcid=RIGHT.rcid, toRestore(LEFT, RIGHT), KEEP(1), HASH); //old code use ds
  ds_restore := JOIN(j1, pDatasetIn, LEFT.rcid=RIGHT.rcid, toRestore(LEFT, RIGHT), KEEP(1), HASH);
  

  /* ---------------------- SALT Output -------------------------------- */
  import BIPV2_QA_Tool,Strata;
  // shared last_lgid3_iter    := '~' + nothor(std.file.superfilecontents(BIPV2_Files.files_lgid3.FILE_BUILDING)[1].name);
  // shared before_restore_ds  := dataset(last_lgid3_iter,l_base,thor);
  // shared restoredDs         := ds_restore;

  /* ---------------------- Persistence stats and QA tool outputs -------------------------------- */
  import LinkingTools;
  ds_lgid3_persistence_stats                 := BIPV2_Strata.PersistenceStats(pDatasetOut,BIPV2.CommonBase.DS_BASE,rcid,lgid3) : independent;
  QA_Tool_lgid3_persistence_record_stats     := BIPV2_QA_Tool.mac_persistence_records_stats(ds_lgid3_persistence_stats ,'lgid3' ,pversion);
  QA_Tool_lgid3_persistence_cluster_stats    := BIPV2_QA_Tool.mac_persistence_cluster_stats(ds_lgid3_persistence_stats ,'lgid3' ,pversion);

  kick_copy2_storage_thor_post  := BIPV2_Tools.Copy2_Storage_Thor(last_lgid3_iter  ,pversion ,'lgid3_postprocess');
  copy2StorageThor_post         := if(pCopy2StorageThor = true ,output(kick_copy2_storage_thor_post ,named('copy2_Storage_Thor__html')));  //copy orig file to storage thor
  
  return sequential(
     output(ds_restore,,  last_lgid3_iter+'_post', compressed, overwrite)
    ,BIPV2_LGID3._ManageLgid3Indexes(before_restore_ds , ds_restore, pversion).out //added for data retrieve
    ,BIPv2_Files.files_lgid3.updateSuperfiles(last_lgid3_iter+'_post')
    ,Strata.macf_CreateXMLStats(ds_lgid3_persistence_stats ,'BIPV2','Persistence'  ,pversion,BIPV2_Build.mod_email.emailList,'LGID3','Stats',false,false) //group on cluster_type, stat_desc
    ,QA_Tool_lgid3_persistence_record_stats 
    ,QA_Tool_lgid3_persistence_cluster_stats
    ,copy2StorageThor_post
  );

end;