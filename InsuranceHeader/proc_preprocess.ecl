import insuranceheader_preprocess, idl_header,InsuranceHeader_Ingest;
import InsuranceHeader_Strata,InsuranceHeader_Salt_T46,InsuranceHeader_Alerts,InsuranceHeader_PostProcess;


export proc_preprocess(string iter ) := module
	
  //Files
	shared oFile                  := idl_header.files.FILE_IDL_SALT_ITER + 'input_' + iter; 
	shared did2rid_File           := idl_header.files.FILE_IDL_DID2RID;
	shared did2rid_processed_File := idl_header.files.FILE_IDL_DID2RID_processed;  
	shared suppressed_File        := idl_header.files.FILE_SUPPRESSED;  
	shared addback_File           := idl_header.files.FILE_SUPPRESSED_ADDBACK;              
	shared addback_processed_File := idl_header.files.FILE_SUPPRESSED_ADDBACK_processed;                        
	
	//Datasets
	shared iDS   := idl_header.Files.DS_SALT_ITER_OUTPUT; 
	shared suppress_DS            := InsuranceHeader_Salt_T46.ManualSuppression.data_file;                
	shared did2rid_DS             := idl_header.files.DS_IDL_DID2RID;
	shared addback_DS             := idl_header.files.DS_SUPPRESSED_ADDBACK;
	
	shared String8 strataVersion := thorlib.wuid()[2..9];
	
	// iHeader build process deletes the input file generated by pre-process at the end of the build process.
	// If file exists in the salt iter super file, which means the build process was not completed
	// successfully.
	
	shared RunIngest        := InsuranceHeader_Ingest.Proc_Ingest(strataVersion); 

	// Generate a new file
	shared ingest           := InsuranceHeader_Ingest.Files.AsHeaderAll_Current_DS; 
  
	shared makeInput(dataset(idl_header.layout_header_link) inds) := FUNCTION
	
		// Suppress Records
		suppressrec := record
			idl_header.Layout_Header_Link;
			boolean isSuppressed;
		end;	
		ApplySuppression := join(inds,
														 suppress_DS,
														 left.ssn         = right.ssn and
														 left.dob         = right.dob and
														 left.dl_nbr      = right.dl_nbr and
														 left.dl_state    = right.dl_state and
														 left.fname       = right.fname and
														 left.mname       = right.mname and
														 left.lname       = right.lname and
														 left.sname       = right.sname and
														 left.gender      = right.gender and
														 left.prim_range  = right.prim_range and
														 left.predir      = right.predir and
														 left.prim_name   = right.prim_name and
														 left.addr_suffix = right.addr_suffix and
														 left.postdir     = right.postdir and
														 left.sec_range   = right.sec_range and
														 left.city        = right.city and
														 left.st          = right.st and
														 left.zip         = right.zip,
														 transform(suppressrec,
																			 self.isSuppressed := right.rid > 0,
																			 self:=left),left outer,lookup);
		generateSuppressedFile   := output(ApplySuppression(isSuppressed),,suppressed_File, overwrite); 
		addToSuperFileSuppressed := InsuranceHeader_PreProcess.SuperFiles.updateSuppressedSuperFiles(suppressed_File);

		 // Check to see if we need to addback any suppressed records from prior suppression
		isAddbackInputEmpty  := fileservices.getsuperfilesubcount(addback_File) = 0;  
		BaseRecs             := PROJECT(ApplySuppression(not isSuppressed),idl_header.Layout_Header_Link);
		AddbackRecs          := PROJECT(addback_DS,idl_header.Layout_Header_Link);
		AddbacksMatches      := join(BaseRecs, AddbackRecs,
																	left.rid = right.rid,lookup);	
		AddbacksOnly         := join(AddbackRecs, AddbacksMatches,
																	left.rid = right.rid,
																	transform(idl_header.Layout_Header_Link,
																						self.did := left.rid,
																						self     := left),left only,lookup);	
		ApplyAddback  := BaseRecs + AddbacksOnly;                       	

		// Reads input file to change did to rid prior to linking
		isDidRidInputEmpty := fileservices.getsuperfilesubcount(did2rid_File) = 0;
		ApplyDidRid        := join(ApplyAddback,did2rid_DS,
																	left.rid = right.rid,
																	transform(idl_header.Layout_Header_Link,
																						self.did := IF(left.rid=right.rid,IF(right.did2=0,right.rid,right.did2),left.did);
																						self := left),left outer,lookup);	
	
	/*--------------------Remove blank clusters from input file---===------------*/
		j1 := ApplyDidRid(not(fname = '' and lname = '' and prim_name = '' and city = ''));
		
		d1 := DEDUP(SORT(DISTRIBUTE(j1,did),did,LOCAL),did,LOCAL);
		filteredDids := JOIN(DISTRIBUTE(ApplyDidRid,did),d1,LEFT.did=RIGHT.did,TRANSFORM(LEFT),LEFT ONLY,LOCAL);
		OUTPUT(COUNT(filteredDids),NAMED('filteredDids'));
		
	 j2 := JOIN(DISTRIBUTE(ApplyDidRid,did),d1,LEFT.did=RIGHT.did,TRANSFORM(LEFT),LOCAL);
	/*----------------------------------------------------------------------------*/
	
		dist_rid := DISTRIBUTE(j2,rid);
		tab_rid := TABLE(dist_rid,{dist_rid.rid,cnt:=COUNT(GROUP)},rid,local);
		OUTPUT(COUNT(tab_rid(cnt > 1)),named('dup_count'));
		
		ded_out := DEDUP(SORT(dist_rid,rid,-dt_effective_first,-dt_vendor_last_reported,local),rid,local);
	
		generateFile   := output(distribute(ded_out, skew(0.01)),,oFile, compressed, overwrite);
		return SEQUENTIAL(generateSuppressedFile,addToSuperFileSuppressed,generateFile);
		
	END;

	shared makeInputBase := makeInput(ingest);
	shared makeInputPass := makeInput(iDS);
	
	shared addToSuperFile  := InsuranceHeader_PreProcess.SuperFiles.updateSaltInputSuperFiles(ofile);							
	
	//generate update stats	and source stats
	shared newInputFile := DATASET(ofile,idl_header.layout_header_link,THOR);
	shared t1:= sequential(InsuranceHeader_Strata.HeaderUpdate(idl_header.files.DS_SALT_ITER_OUTPUT,newInputFile, strataVersion),InsuranceHeader_PostProcess.loadStrata_SourceCount(newInputFile, strataVersion));
	shared alert := InsuranceHeader_Alerts.procData.run;
	
	shared t2 := InsuranceHeader_Ingest.MOD_SourceStats(newInputFile,iter).output_stats;
 
	export runSuppress := sequential(makeInputPass,addToSuperFile,output('iHeader input file exists, skipping data ingest Pre-Process.')):
																						SUCCESS(InsuranceHeader.mod_email.SendSuccessEmail(,'InsuranceHeader', , 'PreProcess')), 
																						FAILURE(InsuranceHeader.mod_email.SendFailureEmail(,'InsuranceHeader', failmessage, 'PreProcess'));
	export run :=			sequential(RunIngest,makeInputBase,addToSuperFile,t1,alert,t2):
																						SUCCESS(InsuranceHeader.mod_email.SendSuccessEmail(,'InsuranceHeader', , 'PreProcess')), 
																						FAILURE(InsuranceHeader.mod_email.SendFailureEmail(,'InsuranceHeader', failmessage, 'PreProcess'));
	
end;