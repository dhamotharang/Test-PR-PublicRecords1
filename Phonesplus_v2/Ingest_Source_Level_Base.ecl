/***********************************************************************************************************************************
	Note: This module was copied from Ingest.ecl code generated by saving _SPC_Source_Level_Ingest.salt and renamed in case 
				we want to ingest other file types in the future in the same module.  If _SPC_Source_Level_Ingest.salt is modified, this 
				code will need to be refreshed.  
				I also changed the names for the named outputs:
					'InputSourceCounts' => 'Source_Level_InputSourceCounts'
					'UpdateStatsSrc' 	=> 'Source_Level_UpdateStatsSrc'
					'UpdateStats'	=>	'Source_Level_UpdateStats'
					'UpdateStatsXtab' 	=> 'Source_Level_UpdateStatsXtab'
					'ValidityStatistics' 	=> 'Source_Level_ValidityStatistics'
					
DF-26609_PhonesPlus_Add_Lexids - added did to the rollup so we keep all 
************************************************************************************************************************************/
IMPORT STD,SALT311;
EXPORT Ingest_Source_Level_Base(BOOLEAN incremental=FALSE
, DATASET(Layout_Source_Level_Base) Delta = DATASET([],Layout_Source_Level_Base)
, DATASET(Layout_Source_Level_Base) dsBase = In_Source_Level_Base // Change IN_Source_Level_Base to change input to ingest process
, DATASET(RECORDOF(PhonesPlus_V2.Prep_Source_Level_Ingest))  infile = PhonesPlus_V2.Prep_Source_Level_Ingest
) := MODULE
  SHARED NullFile := DATASET([],Layout_Source_Level_Base); // Use to replace files you wish to remove
 
  SHARED FilesToIngest := infile;
  In_Src_Cnt_Rec := RECORD
    FilesToIngest.source;
    UNSIGNED Cnt := COUNT(GROUP);
  END;
  EXPORT InputSourceCounts := TABLE(FilesToIngest,In_Src_Cnt_Rec,source,FEW);
  SHARED S0 := OUTPUT(InputSourceCounts,ALL,NAMED('Source_Level_InputSourceCounts'));
  // Now need to discover which records are old / new / updated
  EXPORT RecordType := ENUM(UNSIGNED1,Unknown,Ancient,Old,Unchanged,Updated,New);
  EXPORT RTToText(unsigned1 c) := CHOOSE(c,'UNKNOWN','Ancient','Old','Unchanged','Updated','New','UNKNOWN');
  SHARED WithRT := RECORD
    Layout_Source_Level_Base;
    __Tpe := RecordType.Unknown;
  END;
 
  // Base recs start out Old, Ingest recs start out New -- matched records will become Unchanged or Updated below
  SHARED FilesToIngest0 := PROJECT(FilesToIngest,TRANSFORM(WithRT,SELF.__Tpe:=RecordType.New,SELF:=LEFT));
  SHARED Delta0 := PROJECT(Delta,TRANSFORM(WithRT,SELF.__Tpe:=RecordType.Old,SELF:=LEFT));
  SHARED Base0 := PROJECT(dsBase,TRANSFORM(WithRT,SELF.__Tpe:=RecordType.Old,SELF:=LEFT));
 
  SHARED WithRT MergeData(WithRT le, WithRT ri) := TRANSFORM // Pick the data for the new record
    SELF.datefirstseen := MAP ( le.__Tpe = 0 OR (UNSIGNED)le.datefirstseen = 0 => ri.datefirstseen,
                     ri.__Tpe = 0 OR (UNSIGNED)ri.datefirstseen = 0 => le.datefirstseen,
                     (UNSIGNED)le.datefirstseen < (UNSIGNED)ri.datefirstseen => le.datefirstseen, // Want the lowest non-zero value
                     ri.datefirstseen);
    SELF.datelastseen := MAP ( le.__Tpe = 0 => ri.datelastseen,
                     ri.__Tpe = 0 => le.datelastseen,
                     (UNSIGNED)le.datelastseen < (UNSIGNED)ri.datelastseen => ri.datelastseen, // Want the highest value
                     le.datelastseen);
    SELF.datevendorfirstreported := MAP ( le.__Tpe = 0 OR (UNSIGNED)le.datevendorfirstreported = 0 => ri.datevendorfirstreported,
                     ri.__Tpe = 0 OR (UNSIGNED)ri.datevendorfirstreported = 0 => le.datevendorfirstreported,
                     (UNSIGNED)le.datevendorfirstreported < (UNSIGNED)ri.datevendorfirstreported => le.datevendorfirstreported, // Want the lowest non-zero value
                     ri.datevendorfirstreported);
    SELF.datevendorlastreported := MAP ( le.__Tpe = 0 => ri.datevendorlastreported,
                     ri.__Tpe = 0 => le.datevendorlastreported,
                     (UNSIGNED)le.datevendorlastreported < (UNSIGNED)ri.datevendorlastreported => ri.datevendorlastreported, // Want the highest value
                     le.datevendorlastreported);
    SELF.first_build_date := MAP ( le.__Tpe = 0 OR (UNSIGNED)le.first_build_date = 0 => ri.first_build_date,
                     ri.__Tpe = 0 OR (UNSIGNED)ri.first_build_date = 0 => le.first_build_date,
                     (UNSIGNED)le.first_build_date < (UNSIGNED)ri.first_build_date => le.first_build_date, // Want the lowest non-zero value
                     ri.first_build_date);
    SELF.last_build_date := MAP ( le.__Tpe = 0 => ri.last_build_date,
                     ri.__Tpe = 0 => le.last_build_date,
                     (UNSIGNED)le.last_build_date < (UNSIGNED)ri.last_build_date => ri.last_build_date, // Want the highest value
                     le.last_build_date);
    SELF.dt_nonglb_last_seen := MAP ( le.__Tpe = 0 => ri.dt_nonglb_last_seen,
                     ri.__Tpe = 0 => le.dt_nonglb_last_seen,
                     (UNSIGNED)le.dt_nonglb_last_seen < (UNSIGNED)ri.dt_nonglb_last_seen => ri.dt_nonglb_last_seen, // Want the highest value
                     le.dt_nonglb_last_seen);
    __Tpe0 := MAP (
      le.__Tpe = 0 => ri.__Tpe,
      le.__Tpe = RecordType.Updated OR ri.__Tpe = 0 OR ri.__Tpe = le.__Tpe => le.__Tpe,
      SELF.datefirstseen <> le.datefirstseen OR SELF.datelastseen <> le.datelastseen OR SELF.datevendorfirstreported <> le.datevendorfirstreported OR SELF.datevendorlastreported <> le.datevendorlastreported OR SELF.first_build_date <> le.first_build_date OR SELF.last_build_date <> le.last_build_date OR SELF.dt_nonglb_last_seen <> le.dt_nonglb_last_seen => RecordType.Updated,
      RecordType.Unchanged);
    SELF.__Tpe := __Tpe0;
    SELF := le; // Take current version - noting update if needed
  END;
 
  // Ingest Files: Rollup to get unique new records
  DistIngest0 := DISTRIBUTE(FilesToIngest0, HASH32(
    cellphoneidkey, source, household_flag, did));
  SortIngest0 := SORT(DistIngest0, 
    cellphoneidkey, source, household_flag, did, __Tpe, record_sid, LOCAL);
  GroupIngest0 := GROUP(SortIngest0, 
    cellphoneidkey, source, household_flag, did, LOCAL, ORDERED, STABLE);
  SHARED AllIngestRecs0 := UNGROUP(ROLLUP(GroupIngest0,TRUE,MergeData(LEFT,RIGHT)));
 
  // Existing Base: combine delta with base file
  DistBase0 := DISTRIBUTE(Base0+Delta0, HASH32(
    cellphoneidkey, source, household_flag, did));
  SortBase0 := SORT(DistBase0, 
    cellphoneidkey, source, household_flag, did, __Tpe, record_sid, LOCAL);
  GroupBase0 := GROUP(SortBase0, 
    cellphoneidkey, source, household_flag, did, LOCAL, ORDERED, STABLE);
  SHARED AllBaseRecs0 := UNGROUP(ROLLUP(GroupBase0,TRUE,MergeData(LEFT,RIGHT)));
 
  // Everything: combine ingest and base recs
  Sort0 := SORT(AllBaseRecs0+AllIngestRecs0, 
    cellphoneidkey, source, household_flag, did, __Tpe, record_sid, LOCAL);
  Group0 := GROUP(Sort0, 
    cellphoneidkey, source, household_flag, did, LOCAL, ORDERED, STABLE);
  SHARED AllRecs0 := UNGROUP(ROLLUP(Group0,TRUE,MergeData(LEFT,RIGHT)));
 
  //Now need to update 'rid' numbers on new records
  //Base upon SALT311.utMac_Sequence_Records
  // Do not use PROJECT,COUNTER because it is very slow if any of the fields are not fixed length
  NR := AllRecs0(__Tpe=RecordType.New);
  ORe := AllRecs0(__Tpe<>RecordType.New);
  PrevBase := MAX(ORe,record_sid);
  WithRT AddNewRid(WithRT le, WithRT ri) := TRANSFORM
    SELF.record_sid := IF ( le.record_sid=0, PrevBase+1+thorlib.node(), le.record_sid+thorlib.nodes() );
    SELF := ri;
  END;
  NR1 := ITERATE(NR(record_sid=0),AddNewRid(LEFT,RIGHT),LOCAL);
  SHARED AllRecs := ORe+NR1+NR(record_sid<>0) : PERSIST('~temp::PhonesPlus_V2::Ingest_Cache',EXPIRE(PhonesPlus_V2.Config.PersistExpire));
  SHARED UpdateStatsFull := SORT(TABLE(AllRecs, {__Tpe,SALT311.StrType INGESTSTATUS:=RTToText(AllRecs.__Tpe),UNSIGNED Cnt:=COUNT(GROUP)}, __Tpe, FEW),__Tpe, FEW);
  SHARED UpdateStatsInc := SORT(UpdateStatsFull(__Tpe = RecordType.New), __Tpe, INGESTSTATUS, FEW);
  EXPORT UpdateStats := IF(incremental, UpdateStatsInc, UpdateStatsFull);
  SHARED S1 := OUTPUT(UpdateStats, {{UpdateStats} AND NOT __Tpe}, ALL, NAMED('Source_Level_UpdateStats'));
  SHARED UpdateStatsSrcFull := SORT(TABLE(AllRecs, {source,__Tpe,SALT311.StrType INGESTSTATUS:=RTToText(AllRecs.__Tpe),UNSIGNED Cnt:=COUNT(GROUP)}, source,__Tpe, FEW),source,__Tpe, FEW);
  SHARED UpdateStatsSrcInc := SORT(UpdateStatsSrcFull(__Tpe = RecordType.New), source,__Tpe, INGESTSTATUS, FEW);
  EXPORT UpdateStatsSrc := IF(incremental, UpdateStatsSrcInc, UpdateStatsSrcFull);
  SHARED S2 := OUTPUT(UpdateStatsSrc, {{UpdateStatsSrc} AND NOT __Tpe}, ALL, NAMED('Source_Level_UpdateStatsSrc'));
 
  SHARED l_roll := RECORD
    UpdateStatsSrc.source;
    unsigned cnt_Old;
    unsigned cnt_Unchanged;
    unsigned cnt_Updated;
    unsigned cnt_New;
    unsigned pct_tot_Old;
    unsigned pct_tot_Unchanged;
    unsigned pct_tot_Updated;
    unsigned pct_tot_New;
    unsigned pct_ingest_Unchanged;
    unsigned pct_ingest_Updated;
    unsigned pct_ingest_New;
  END;
  SHARED l_roll toRoll(UpdateStatsSrc L) := TRANSFORM
    SELF.cnt_Old := IF(L.__Tpe=RecordType.Old, L.Cnt, 0);
    SELF.cnt_Unchanged := IF(L.__Tpe=RecordType.Unchanged, L.Cnt, 0);
    SELF.cnt_Updated := IF(L.__Tpe=RecordType.Updated, L.Cnt, 0);
    SELF.cnt_New := IF(L.__Tpe=RecordType.New, L.Cnt, 0);
    SELF := L;
    SELF := [];
  END;
  SHARED l_roll doRoll(l_roll L, l_roll R) := TRANSFORM
    SELF.cnt_Old := IF(L.cnt_Old<>0, L.cnt_Old, R.cnt_Old);
    SELF.cnt_Unchanged := IF(L.cnt_Unchanged<>0, L.cnt_Unchanged, R.cnt_Unchanged);
    SELF.cnt_Updated := IF(L.cnt_Updated<>0, L.cnt_Updated, R.cnt_Updated);
    SELF.cnt_New := IF(L.cnt_New<>0, L.cnt_New, R.cnt_New);
    SELF := L;
  END;
  SHARED l_roll toPct(l_roll L) := TRANSFORM
    cnt_tot := L.cnt_old + L.cnt_unchanged + L.cnt_updated + L.cnt_new;
    cnt_ingest := L.cnt_unchanged + L.cnt_updated + L.cnt_new;
    SELF.pct_tot_Old := 100.0 * L.cnt_Old / cnt_tot;
    SELF.pct_tot_Unchanged := 100.0 * L.cnt_Unchanged / cnt_tot;
    SELF.pct_tot_Updated := 100.0 * L.cnt_Updated / cnt_tot;
    SELF.pct_tot_New := 100.0 * L.cnt_New / cnt_tot;
    SELF.pct_ingest_Unchanged := 100.0 * L.cnt_Unchanged / cnt_ingest;
    SELF.pct_ingest_Updated := 100.0 * L.cnt_Updated / cnt_ingest;
    SELF.pct_ingest_New := 100.0 * L.cnt_New / cnt_ingest;
    SELF := L;
  END;
  SHARED UpdateStatsXtab := PROJECT(ROLLUP(PROJECT(SORT(UpdateStatsSrc,source),toRoll(LEFT)),doRoll(LEFT,RIGHT),source),toPct(LEFT));
  SHARED S3 := IF(~incremental, OUTPUT(UpdateStatsXtab,ALL,NAMED('Source_Level_UpdateStatsXtab')));
 
  SHARED NoFlagsRec := WithRT;
  SHARED emptyDS := DATASET([], NoFlagsRec);
  EXPORT NewRecords := PROJECT(AllRecs(__Tpe=RecordType.New), NoFlagsRec);
  EXPORT NewRecords_NoTag := PROJECT(NewRecords,Layout_Source_Level_Base);
  EXPORT OldRecords :=PROJECT( AllRecs(__Tpe=RecordType.Old), NoFlagsRec);
  EXPORT OldRecords_NoTag := PROJECT(OldRecords,Layout_Source_Level_Base);
  EXPORT UpdatedRecords := PROJECT(AllRecs(__Tpe=RecordType.Updated), NoFlagsRec);
  EXPORT UpdatedRecords_NoTag := PROJECT(UpdatedRecords,Layout_Source_Level_Base);
  EXPORT AllRecords := IF(incremental, NewRecords, PROJECT(AllRecs, NoFlagsRec));
  EXPORT AllRecords_NoTag := PROJECT(AllRecords,Layout_Source_Level_Base); // Records in 'pure' format
 
f := TABLE(dsBase,{record_sid}) : GLOBAL;
rcid_clusters := SALT311.MOD_ClusterStats.Counts(f,record_sid);
DuplicateRids0 := COUNT(dsBase) - SUM(rcid_clusters,NumberOfClusters); // Should be zero
d := DATASET([{DuplicateRids0}],{UNSIGNED2 DuplicateRids0});
EXPORT ValidityStats := OUTPUT(d,NAMED('Source_Level_ValidityStatistics'));
  EXPORT DoStats := PARALLEL(S0,S1,S2,S3);
 
  EXPORT StandardStats(BOOLEAN doInfileOverallCnt = TRUE, BOOLEAN doStatusOverallCnt = TRUE, BOOLEAN doInfilePerSrcCnt = TRUE, BOOLEAN doStatusPerSrcCnt = TRUE) := FUNCTION
    myTimeStamp := (UNSIGNED6)SALT311.Fn_Now('YYYYMMDDHHMMSS') : INDEPENDENT;
    infileCntOverall := IF(doInfileOverallCnt, SALT311.mod_StandardStatsTransforms.MAC_ingestInfileOverallCount(COUNT(FilesToIngest), 'Infile', myTimeStamp));
    basefileCntOverall := IF(doInfileOverallCnt, SALT311.mod_StandardStatsTransforms.MAC_ingestInfileOverallCount(COUNT(dsBase), 'Basefile', myTimeStamp));
    deltaCntOverall := IF(doInfileOverallCnt, SALT311.mod_StandardStatsTransforms.MAC_ingestInfileOverallCount(COUNT(Delta), 'Deltafile', myTimeStamp));
    sourceCountsStandard := IF(doInfilePerSrcCnt, SALT311.mod_StandardStatsTransforms.MAC_ingestInfileSourceCounts(InputSourceCounts, source, myTimeStamp));
    ingestStatusOverall := IF(doStatusOverallCnt, SALT311.mod_StandardStatsTransforms.MAC_ingestStatus(UpdateStats,, myTimeStamp));
    ingestStatusPerSrc := IF(doStatusPerSrcCnt, SALT311.mod_StandardStatsTransforms.MAC_ingestStatus(UpdateStatsSrc, source, myTimeStamp));
    standardStats := infileCntOverall & basefileCntOverall & ingestStatusOverall & sourceCountsStandard & ingestStatusPerSrc;
    RETURN standardStats;
  END;
END;
