Generated by SALT V3.0 Gold
File being processed :-
MODULE:BIPV2_Best_Seleid
FILENAME:Base
// Uncomment up to NINES for internal or external adl
IDFIELD:EXISTS:Seleid
RIDFIELD:rcid
RECORDS:3000000000
POPULATION:3000000000
NINES:3
// FIELDTYPE statements can be used to clean up (or check the cleaning) of individual fields
FIELDTYPE:wordbag:CAPS:ALLOW(ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):SPACES( <>{}[]-^=!+&,./):ONFAIL(CLEAN)
FIELDTYPE:alpha:CAPS:ALLOW(ABCDEFGHIJKLMNOPQRSTUVWXYZ)
FIELDTYPE:number:ALLOW(0123456789)
FIELDTYPE:upper:CAPS:ONFAIL(CLEAN)
FIELDTYPE:cname:CAPS:ONFAIL(CLEAN)
FIELD:dt_first_seen:RECORDDATE(FIRST):0,0
FIELD:dt_last_seen:RECORDDATE(LAST):0,0
FIELD:source_for_votes:CARRY
SOURCEFIELD:source_for_votes:PERMITS(fn_sources,10)
//BESTTYPE statements declare methods of generating the best value for a given cluster
//Company Name
BESTTYPE:BestCompanyNameLegal:BASIS(Seleid):VOTED(fn_Best_Name_Legal_Votes):FUZZY:VALID(fn_valid_cname):EXTEND
BESTTYPE:BestCompanyNameVotedSeleLevel:BASIS(Seleid):VOTED(fn_Best_Sele_Level_Votes,2):VALID(fn_valid_cname):EXTEND
BESTTYPE:BestCompanyNameCommon:BASIS(Seleid):COMMONEST:FUZZY:MINIMUM(2):VALID(fn_valid_cname):EXTEND
BESTTYPE:BestCompanyNameCurrent:BASIS(Seleid):RECENT(dt_last_seen):FUZZY:MINIMUM(2):VALID(fn_valid_cname):EXTEND
BESTTYPE:BestCompanyNameVoted:BASIS(Seleid):VOTED(fn_Best_Name_Source_Votes,2):VALID(fn_valid_cname):EXTEND
BESTTYPE:BestCompanyNameLength:BASIS(Seleid):LONGEST:FUZZY:VALID(fn_valid_cname):EXTEND
BESTTYPE:BestCompanyNameStrong:BASIS(Seleid):UNIQUE:FUZZY:VALID(fn_valid_cname):EXTEND
BESTTYPE:BestCompanyNameCurrent2:BASIS(Seleid):RECENT(dt_last_seen):VALID(fn_valid_cname):EXTEND
BESTTYPE:BestCompanyNameVotedUnrestricted:BASIS(Seleid):VOTED(fn_Best_Source_Unrestricted_Votes,2):VALID(fn_valid_cname):EXTEND
//Address
BESTTYPE:BestCompanyAddressVotedSeleLevel:BASIS(Seleid):VOTED(fn_Best_Sele_Level_Votes,2):VALID(fn_valid_caddress):EXTEND
BESTTYPE:BestCompanyAddressVoted:BASIS(Seleid):VOTED(fn_Best_Address_Fields_Votes,2):VALID(fn_valid_caddress):EXTEND
BESTTYPE:BestCompanyAddressCurrent:BASIS(Seleid):RECENT(dt_last_seen):FUZZY:MINIMUM(2):VALID(fn_valid_caddress):EXTEND
BESTTYPE:BestCompanyAddressVotedSrc:BASIS(Seleid):VOTED(fn_Best_Address_Source_Votes,2):VALID(fn_valid_caddress):EXTEND
BESTTYPE:BestCompanyAddressCommon:BASIS(Seleid):COMMONEST:FUZZY:MINIMUM(2):VALID(fn_valid_caddress):EXTEND
BESTTYPE:BestCompanyAddressLength:BASIS(Seleid):LONGEST:FUZZY:VALID(fn_valid_caddress):EXTEND
BESTTYPE:BestCompanyAddressStrong:BASIS(Seleid):UNIQUE:FUZZY:VALID(fn_valid_caddress):EXTEND
BESTTYPE:BestSecRange:BASIS(Seleid:company_prim_range:company_prim_name:company_zip5):COMMONEST:FUZZY:EXTEND
BESTTYPE:BestCompanyAddressCurrent2:BASIS(Seleid):RECENT(dt_last_seen):VALID(fn_valid_caddress):EXTEND
BESTTYPE:BestCompanyAddressVotedUnrestricted:BASIS(Seleid):VOTED(fn_Best_Source_Unrestricted_Votes,2):FUZZY:VALID(fn_valid_caddress):EXTEND
//Phone
BESTTYPE:BestPhoneVotedSeleLevelWithNpa:BASIS(Seleid):VOTED(fn_Best_Sele_Level_Votes,2):VALID(fn_valid_cphone10):EXTEND
BESTTYPE:BestPhoneCurrentWithNpa:BASIS(Seleid):RECENT(dt_last_seen):FUZZY:VALID(fn_valid_cphone10):EXTEND
BESTTYPE:BestPhoneCurrent:BASIS(Seleid):RECENT(dt_last_seen):FUZZY:VALID(fn_valid_cphone7):EXTEND
BESTTYPE:BestPhoneVoted:BASIS(Seleid):VOTED(fn_Best_Phone_Votes,2):FUZZY:VALID(fn_valid_cphone7):EXTEND
BESTTYPE:BestPhoneLongest:BASIS(Seleid):LONGEST:FUZZY:VALID(fn_valid_cphone7):EXTEND
BESTTYPE:BestPhoneStrong:BASIS(Seleid):UNIQUE:FUZZY:VALID(fn_valid_cphone7):EXTEND
BESTTYPE:BestPhoneVotedUnrestricted:BASIS(Seleid):VOTED(fn_Best_Source_Unrestricted_Votes,2):FUZZY:VALID(fn_valid_cphone10):EXTEND
BESTTYPE:BestPhoneCommon:BASIS(Seleid):COMMONEST:FUZZY:MINIMUM(2):VALID(fn_valid_cphone10):EXTEND
//TIN
BESTTYPE:BestFeinStrong:BASIS(Seleid):UNIQUE:FUZZY:VALID(fn_valid_cfein):EXTEND
BESTTYPE:BestFeinCommon:BASIS(Seleid):COMMONEST:FUZZY:MINIMUM(2):VALID(fn_valid_cfein):EXTEND
BESTTYPE:BestFeinCurrent:BASIS(Seleid):RECENT(dt_last_seen):FUZZY:VALID(fn_valid_cfein):EXTEND
BESTTYPE:BestFeinVotedUnrestricted:BASIS(Seleid):VOTED(fn_Best_Source_Unrestricted_Votes,2):VALID(fn_valid_cfein):EXTEND
BESTTYPE:BestFeinMin:BASIS(Seleid):VOTED(fn_Best_Fein_Votes_Min,2):FUZZY:VALID(fn_valid_cfein):EXTEND
BESTTYPE:BestFeinMax:BASIS(Seleid):VOTED(fn_Best_Fein_Votes_Max,2):FUZZY:VALID(fn_valid_cfein):EXTEND
//BESTTYPE:BestFeinVoted:BASIS(Seleid):VOTED(BestFeinVotes,2):FUZZY:VALID(fn_valid_cfein):PROP
//URL
BESTTYPE:BestUrlCommon:BASIS(Seleid):COMMONEST:FUZZY:MINIMUM(2):VALID(fn_valid_curl):EXTEND
BESTTYPE:BestUrlCurrent:BASIS(Seleid):RECENT(dt_last_seen):FUZZY:VALID(fn_valid_curl):EXTEND
BESTTYPE:BestUrlLength:BASIS(Seleid):LONGEST:FUZZY:VALID(fn_valid_curl):EXTEND
BESTTYPE:BestUrlStrong:BASIS(Seleid):UNIQUE:FUZZY:VALID(fn_valid_curl):EXTEND
BESTTYPE:BestUrlVotedUnrestricted:BASIS(Seleid):VOTED(fn_Best_Source_Unrestricted_Votes,2):VALID(fn_valid_curl):EXTEND
//DUN_NUMBER
BESTTYPE:BestDunsCommon:BASIS(Seleid):COMMONEST:FUZZY:MINIMUM(2):VALID(fn_valid_duns):EXTEND
BESTTYPE:BestDunsCurrent:BASIS(Seleid):RECENT(dt_last_seen):FUZZY:MINIMUM(2):VALID(fn_valid_duns):EXTEND
BESTTYPE:BestDunsCurrent2:BASIS(Seleid):RECENT(dt_last_seen):VALID(fn_valid_duns):EXTEND
BESTTYPE:BestDunsVotedUnrestricted:BASIS(Seleid):VOTED(fn_Best_Source_Unrestricted_Votes,2):VALID(fn_valid_duns):EXTEND
//SIC
BESTTYPE:BestSicCommon:BASIS(Seleid):COMMONEST:MINIMUM(2):EXTEND
BESTTYPE:BestSicCurrent:BASIS(Seleid):RECENT(dt_last_seen):MINIMUM(2):EXTEND
//NAICS
BESTTYPE:BestNaicsCommon:BASIS(Seleid):COMMONEST:MINIMUM(2):EXTEND
BESTTYPE:BestNaicsCurrent:BASIS(Seleid):RECENT(dt_last_seen):MINIMUM(2):EXTEND
// FUZZY can be used to create new types of FUZZY linking
FUZZY:Right4:RST:CUSTOM(fn_Right4):TYPE(STRING4)
FUZZY:PreferredName:RST:CUSTOM(fn_PreferredName):TYPE(STRING20)
// ------------------------------------
//  1. Company fields
// ------------------------------------
//FIELD:company_name:LIKE(cname):EDIT1:BestCompanyNameCommon:BestCompanyNameCurrent:BestCompanyNameVoted:BestCompanyNameLength:FLAG:19,137
//FIELD:company_name:LIKE(cname):BestCompanyNameCommon:BestCompanyNameCurrent:BestCompanyNameVoted:BestCompanyNameLength:FLAG:19,137
FIELD:company_name:LIKE(cname):BestCompanyNameLegal:BestCompanyNameVotedSeleLevel:BestCompanyNameCommon:BestCompanyNameCurrent:BestCompanyNameVoted:BestCompanyNameLength:BestCompanyNameStrong:BestCompanyNameCurrent2:BestCompanyNameVotedUnrestricted:FLAG:26,371
//FIELD:cnp_name:LIKE(cname):0,0
//FIELD:cnp_number:LIKE(alpha):0, 0
//FIELD:cnp_btype:LIKE(alpha):0,0
//FIELD:cnp_lowv:LIKE(alpha):0,0
//CONCEPT:company_name_clean:LIKE(cname):EDIT2:BestCompanyNameCommon:BestCompanyNameCurrent:BestCompanyNameVoted:BestCompanyNameLength:BestCompanyNameStrong:BestCompanyNameCurrent2:BestCompanyNameVotedUnrestricted:FLAG:25,360
FIELD:company_fein:LIKE(number):right4:EDIT1:BestFeinStrong:BestFeinCommon:BestFeinCurrent:BestFeinVotedUnrestricted:BestFeinMin:BestFeinMax:OWNED:FLAG:27,136
FIELD:company_phone:LIKE(number):EDIT1:BestPhoneVotedSeleLevelWithNpa:BestPhoneCurrentWithNpa:BestPhoneCurrent:BestPhoneVoted:BestPhoneLongest:BestPhoneStrong:BestPhoneVotedUnrestricted:BestPhoneCommon:FLAG:26,295
FIELD:company_url:BestUrlCommon:BestUrlCurrent:BestUrlLength:BestUrlStrong:BestUrlVotedUnrestricted:FLAG:27,27
FIELD:duns_number:EDIT1:LIKE(number):BestDunsCommon:BestDunsCurrent:BestDunsCurrent2:BestDunsVotedUnrestricted:FLAG:27,77
FIELD:company_sic_code1:BestSicCommon:BestSicCurrent:FLAG:11,324
FIELD:company_naics_code1:BestNaicsCommon:BestNaicsCurrent:FLAG:11,132
// ------------------------------------
//  2. company Address fields
// ------------------------------------
FIELD:prim_range:13,111
FIELD:predir:4,56
FIELD:prim_name:15,128
FIELD:addr_suffix:3,89
FIELD:postdir:7,42
FIELD:unit_desig:5,64
FIELD:sec_range:FORCE(--):12,167
FIELD:p_city_name:12,100
FIELD:v_city_name:11,77
FIELD:st:LIKE(alpha):5,16
FIELD:zip:LIKE(number):14,99
FIELD:zip4:LIKE(number):13,177
FIELD:fips_state:LIKE(number):5,16
FIELD:fips_county:LIKE(number):7,89
CONCEPT:address:prim_range:predir:prim_name:addr_suffix:postdir:unit_desig:sec_range:st:zip:BestCompanyAddressVotedSeleLevel:BestCompanyAddressVoted:BestCompanyAddressCurrent:BestCompanyAddressVotedSrc:BestCompanyAddressCommon:BestCompanyAddressStrong:BestCompanyAddressCurrent2:BestCompanyAddressVotedUnrestricted:FLAG:25,226
// BESTTYPE statements declare methods of generating the best value for a given cluster; this can also improve linking
// CONCEPT statements should be used to group together interellated fields; such as address
// RELATIONSHIP is used to find non-obvious relationships between the clusters
// SOURCEFIELD is used if a field of the file denotes a source of the records in that file
// LINKPATH is used to define access paths for external linking
// DotID
// a contact name (or the absence of a contact) at a company name at a physical address.  Separate legal entities within an office will consist of //separate //Dots.
// Seleid
// 1. A legal entity at a physical address. (fuzzy matching to account for typos and different representations of same name)
// 2. has no more than 1 active charter for a given state (fuzzy matching to account for typos).  Now this should allow for charters from different states
//    to be ok, but not two charters in the same state.
// 3. has no more than 1 active Duns or LNCA lowest level ID.
// 4. Has no more than 1 status (active vs defunct).
// 5. Has no more than 1 legal name.
// 6. FEIN is sometimes useful for pulling records together, but won't be pushed to push records apart.
// 7. Unincorporated businesses will need more than just company name & address to bring them together into a Prox.  Address + contact is enough.
// Beyond Seleid
// 1. LNCA hierarchy
// 2. Duns hierarchy
// Business Relatives (outside of hierarchy - linkable from a report)
// TBD, but essentially any other connection we come across in this process but do not feel is strong enough for Seleid linking.
Total available specificity:306
Specificity number that should imply one record specified 31.
Assuming an average of 1 records per cluster
Specificity value at which N^2 joins will be tolerated: 25
Recommended matching threshold 41
Search Threshold set at 20
Use of PERSISTs in code set at:3
______________________________English Description of Matching Process___________________________
A SALT generated matching process really only contains one single matching rule.
SALT compares every record to every possible matching record and then allocates a score to how well
the records match. SALT then pairs those clusters which have the highest match scores provided the scores
meet or exceed the matching threshold. The scoring process is highly sophisticated and detailed below
however it can essentially be thought of as allocating points for every pair of fields that match
and subtracting points for every pair of fields that do not match.
This process was told to produce 3 nines of accuracy on a population of -2147483648 with  3000000000 records.
The matching threshold is therefore set at 41.
___Field by Field Breakdown of Scoring Method___
dt_first_seen Scoring: Date fields are not presently used for scoring but are carried along for debugging purposes
dt_last_seen Scoring: Date fields are not presently used for scoring but are carried along for debugging purposes
source_for_votes Scoring: This field is not used for scoring; rather it is carried along for context and debugging
company_name Scoring:
Prior to matching the following rules are applied in a cascade in an attempt to fix or complete field values.
 1. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cname.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Name_Legal_Votes which takes count and source into account.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 2. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cname.
 The number of each field value are then counted.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Sele_Level_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 3. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cname.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is the most commonly occurring field value and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 4. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cname.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 5. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cname.
 The number of each field value are then counted.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Name_Source_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 6. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cname.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which has the most complete (non-null) value of all the field values.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 7. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cname.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is unique or at least fuzzily-equal to every value gathered.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 8. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cname.
 The number of each field value are then counted.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 9. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cname.
 The number of each field value are then counted.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Source_Unrestricted_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
Two company_name fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the company_name
but should average 26 points with a failed match substracting 16 points.
(This subtraction estimate is based upon 37% of clusters with 2 or more records have 2 or more values for company_name.)
company_fein Scoring:
Prior to matching the following rules are applied in a cascade in an attempt to fix or complete field values.
 1. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cfein.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is unique or at least fuzzily-equal to every value gathered.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 2. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cfein.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is the most commonly occurring field value and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 3. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cfein.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 4. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cfein.
 The number of each field value are then counted.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Source_Unrestricted_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 5. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cfein.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Fein_Votes_Min which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 6. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cfein.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Fein_Votes_Max which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
Two company_fein fields will be considered to match if:
  - they are identical
  - one can be turned into the other with 1 edit (see Glossary)
  - if the two fields have the same value for the function Right4
The exact number of points allocated to a match will depend upon the global scarcity of the company_fein
and the degree of fuzziness required but should average 27 points with a failed match substracting 23 points.
(This subtraction estimate is based upon 13% of clusters with 2 or more records have 2 or more values for company_fein.)
company_phone Scoring:
Prior to matching the following rules are applied in a cascade in an attempt to fix or complete field values.
 1. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cphone10.
 The number of each field value are then counted.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Sele_Level_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 2. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cphone10.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 3. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cphone7.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 4. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cphone7.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Phone_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 5. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cphone7.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which has the most complete (non-null) value of all the field values.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 6. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cphone7.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is unique or at least fuzzily-equal to every value gathered.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 7. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cphone10.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Source_Unrestricted_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 8. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_cphone10.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is the most commonly occurring field value and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
Two company_phone fields will be considered to match if:
  - they are identical
  - one can be turned into the other with 1 edit (see Glossary)
The exact number of points allocated to a match will depend upon the global scarcity of the company_phone
and the degree of fuzziness required but should average 26 points with a failed match substracting 18 points.
(This subtraction estimate is based upon 29% of clusters with 2 or more records have 2 or more values for company_phone.)
company_url Scoring:
Prior to matching the following rules are applied in a cascade in an attempt to fix or complete field values.
 1. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_curl.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is the most commonly occurring field value and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 2. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_curl.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 3. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_curl.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which has the most complete (non-null) value of all the field values.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 4. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_curl.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is unique or at least fuzzily-equal to every value gathered.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 5. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_curl.
 The number of each field value are then counted.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Source_Unrestricted_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
Two company_url fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the company_url
but should average 27 points with a failed match substracting 26 points.
(This subtraction estimate is based upon 2% of clusters with 2 or more records have 2 or more values for company_url.)
duns_number Scoring:
Prior to matching the following rules are applied in a cascade in an attempt to fix or complete field values.
 1. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_duns.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is the most commonly occurring field value and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 2. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_duns.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 3. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_duns.
 The number of each field value are then counted.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 4. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_duns.
 The number of each field value are then counted.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Source_Unrestricted_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
Two duns_number fields will be considered to match if:
  - they are identical
  - one can be turned into the other with 1 edit (see Glossary)
The exact number of points allocated to a match will depend upon the global scarcity of the duns_number
and the degree of fuzziness required but should average 27 points with a failed match substracting 24 points.
(This subtraction estimate is based upon 7% of clusters with 2 or more records have 2 or more values for duns_number.)
company_sic_code1 Scoring:
Prior to matching the following rules are applied in a cascade in an attempt to fix or complete field values.
 1. Gather together all records that match on (Seleid,data_permits).
 The number of each field value are then counted.
 The best is then defined to be the one which is the most commonly occurring field value and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 2. Gather together all records that match on (Seleid,data_permits).
 The number of each field value are then counted.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
Two company_sic_code1 fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the company_sic_code1
but should average 11 points with a failed match substracting 7 points.
(This subtraction estimate is based upon 32% of clusters with 2 or more records have 2 or more values for company_sic_code1.)
company_naics_code1 Scoring:
Prior to matching the following rules are applied in a cascade in an attempt to fix or complete field values.
 1. Gather together all records that match on (Seleid,data_permits).
 The number of each field value are then counted.
 The best is then defined to be the one which is the most commonly occurring field value and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 2. Gather together all records that match on (Seleid,data_permits).
 The number of each field value are then counted.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
Two company_naics_code1 fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the company_naics_code1
but should average 11 points with a failed match substracting 9 points.
(This subtraction estimate is based upon 13% of clusters with 2 or more records have 2 or more values for company_naics_code1.)
prim_range Scoring: Two prim_range fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the prim_range
but should average 13 points with a failed match substracting 11 points.
(This subtraction estimate is based upon 11% of clusters with 2 or more records have 2 or more values for prim_range.)
It should also be noted that prim_range is a child field of address. Therefore if address is a full match this field will score 0.
This field is scaled to match with its parent address, on average that will mean multiplying by 32%
predir Scoring: Two predir fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the predir
but should average 4 points with a failed match substracting 3 points.
(This subtraction estimate is based upon 5% of clusters with 2 or more records have 2 or more values for predir.)
It should also be noted that predir is a child field of address. Therefore if address is a full match this field will score 0.
This field is scaled to match with its parent address, on average that will mean multiplying by 32%
prim_name Scoring: Two prim_name fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the prim_name
but should average 15 points with a failed match substracting 13 points.
(This subtraction estimate is based upon 12% of clusters with 2 or more records have 2 or more values for prim_name.)
It should also be noted that prim_name is a child field of address. Therefore if address is a full match this field will score 0.
This field is scaled to match with its parent address, on average that will mean multiplying by 32%
addr_suffix Scoring: Two addr_suffix fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the addr_suffix
but should average 3 points with a failed match substracting 2 points.
(This subtraction estimate is based upon 8% of clusters with 2 or more records have 2 or more values for addr_suffix.)
It should also be noted that addr_suffix is a child field of address. Therefore if address is a full match this field will score 0.
This field is scaled to match with its parent address, on average that will mean multiplying by 32%
postdir Scoring: Two postdir fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the postdir
but should average 7 points with a failed match substracting 6 points.
(This subtraction estimate is based upon 4% of clusters with 2 or more records have 2 or more values for postdir.)
It should also be noted that postdir is a child field of address. Therefore if address is a full match this field will score 0.
This field is scaled to match with its parent address, on average that will mean multiplying by 32%
unit_desig Scoring: Two unit_desig fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the unit_desig
but should average 5 points with a failed match substracting 4 points.
(This subtraction estimate is based upon 6% of clusters with 2 or more records have 2 or more values for unit_desig.)
It should also be noted that unit_desig is a child field of address. Therefore if address is a full match this field will score 0.
This field is scaled to match with its parent address, on average that will mean multiplying by 32%
sec_range Scoring: In order for two records to be a match it is also required that the sec_range fields not not match.
Two sec_range fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the sec_range
but should average 12 points with a failed match substracting 9 points.
(This subtraction estimate is based upon 16% of clusters with 2 or more records have 2 or more values for sec_range.)
It should also be noted that sec_range is a child field of address. Therefore if address is a full match this field will score 0.
This field is scaled to match with its parent address, on average that will mean multiplying by 32%
(Although the score is still computed to satisfy the forcing condition.)
p_city_name Scoring: Two p_city_name fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the p_city_name
but should average 12 points with a failed match substracting 10 points.
(This subtraction estimate is based upon 10% of clusters with 2 or more records have 2 or more values for p_city_name.)
v_city_name Scoring: Two v_city_name fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the v_city_name
but should average 11 points with a failed match substracting 10 points.
(This subtraction estimate is based upon 7% of clusters with 2 or more records have 2 or more values for v_city_name.)
st Scoring: Two st fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the st
but should average 5 points with a failed match substracting 4 points.
(This subtraction estimate is based upon 1% of clusters with 2 or more records have 2 or more values for st.)
It should also be noted that st is a child field of address. Therefore if address is a full match this field will score 0.
This field is scaled to match with its parent address, on average that will mean multiplying by 32%
zip Scoring: Two zip fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the zip
but should average 14 points with a failed match substracting 12 points.
(This subtraction estimate is based upon 9% of clusters with 2 or more records have 2 or more values for zip.)
It should also be noted that zip is a child field of address. Therefore if address is a full match this field will score 0.
This field is scaled to match with its parent address, on average that will mean multiplying by 32%
zip4 Scoring: Two zip4 fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the zip4
but should average 13 points with a failed match substracting 10 points.
(This subtraction estimate is based upon 17% of clusters with 2 or more records have 2 or more values for zip4.)
fips_state Scoring: Two fips_state fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the fips_state
but should average 5 points with a failed match substracting 4 points.
(This subtraction estimate is based upon 1% of clusters with 2 or more records have 2 or more values for fips_state.)
fips_county Scoring: Two fips_county fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the fips_county
but should average 7 points with a failed match substracting 6 points.
(This subtraction estimate is based upon 8% of clusters with 2 or more records have 2 or more values for fips_county.)
address Scoring:
Prior to matching the following rules are applied in a cascade in an attempt to fix or complete field values.
 1. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_caddress.
 The number of each field value are then counted.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Sele_Level_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 2. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_caddress.
 The number of each field value are then counted.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Address_Fields_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 3. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_caddress.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 4. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_caddress.
 The number of each field value are then counted.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Address_Source_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 5. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_caddress.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is the most commonly occurring field value and which has at least 2 records with that field value.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 6. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_caddress.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which is unique or at least fuzzily-equal to every value gathered.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 7. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_caddress.
 The number of each field value are then counted.
 The best is then defined to be the one which has the most recent date recorded in:dt_last_seen.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
 8. Gather together all records that match on (Seleid,source_for_votes,data_permits) removing any which are invalid according to fn_valid_caddress.
 The number of each field value are then counted, field values with a smaller count are used to re-enforce higher count fields that they fuzzy-match to.
 The best is then defined to be the one which recieved most votes based upon the attribute:fn_Best_Source_Unrestricted_Votes which takes count and source into account by a margin of at least 2.
 If the value generated is non-null and the value currently in the field is a shorter form of it then the value currently in the field will be replaced.
Two address fields will be considered to match if:
  - they are identical
Note: address is an amalgam of (prim_range,predir,prim_name,addr_suffix,postdir,unit_desig,sec_range,st,zip)
Points will only be allocated for a match, the amount depending upon the scarcity of address
but should average 25 points.
In the event of a non-match this field will score 0 (and the child fields will be allowed to score).
__Glossary__
Edit Distance: An edit distance of (say) one implies that one string can be converted into another by doing one of
  - Changing one character
  - Deleting one character
  - Transposing two characters
Forcing Criteria: In addition to the general 'best match' logic it is possible to insist that
one particular field must match to some degree or the whole record is considered a bad match.
The criterial applied to that one field is the forcing criteria.
Cascade: Best Type rules are applied in such a way that the rules are applied one by one UNTIL the first rule succeeds; subsequent rules are then skipped.
__General Notes__
How is it decided how much to subtract for a bad match?
SALT computes for each field the percentage likelihood that a valid cluster will have two or more values for a given field
this value (called the switch value in the SALT literature) is then used to produce the subtraction value from the match value.
The value in this document is the one typed into the SPC file; the code will use a value computed at run-time.