IMPORT SALT30,ut;
EXPORT BasicMatch(DATASET(layout_HealthFacility) ih) := MODULE// An extremely tight pre-match designed to quickly eliminate high volume duplicates
SHARED  h00 := Specificities(ih).input_file;
  SHARED s := Specificities(ih).specificities[1];
  SHARED h00_match := h00( 
      0 + IF( NPI_NUMBER  IN SET(s.nulls_NPI_NUMBER,NPI_NUMBER), 0, 22 ) + IF( DEA_NUMBER  IN SET(s.nulls_DEA_NUMBER,DEA_NUMBER), 0, 21 ) + IF( CLIA_NUMBER  IN SET(s.nulls_CLIA_NUMBER,CLIA_NUMBER), 0, 22 ) + IF( MEDICARE_FACILITY_NUMBER  IN SET(s.nulls_MEDICARE_FACILITY_NUMBER,MEDICARE_FACILITY_NUMBER), 0, 21 ) + IF( NCPDP_NUMBER  IN SET(s.nulls_NCPDP_NUMBER,NCPDP_NUMBER), 0, 22 ) + IF( TAX_ID  IN SET(s.nulls_TAX_ID,TAX_ID), 0, 21 ) + IF( FEIN  IN SET(s.nulls_FEIN,FEIN), 0, 17 ) + IF( C_LIC_NBR  IN SET(s.nulls_C_LIC_NBR,C_LIC_NBR), 0, 19 ) + IF( CNP_NAME  IN SET(s.nulls_CNP_NAME,CNP_NAME), 0, 13 ) + IF( CNP_NUMBER  IN SET(s.nulls_CNP_NUMBER,CNP_NUMBER), 0, 13 ) + IF( CNP_STORE_NUMBER  IN SET(s.nulls_CNP_STORE_NUMBER,CNP_STORE_NUMBER), 0, 20 ) + IF( CNP_BTYPE  IN SET(s.nulls_CNP_BTYPE,CNP_BTYPE), 0, 4 ) + IF( PRIM_RANGE  IN SET(s.nulls_PRIM_RANGE,PRIM_RANGE), 0, 12 ) + IF( PRIM_NAME  IN SET(s.nulls_PRIM_NAME,PRIM_NAME), 0, 13 ) + IF( SEC_RANGE  IN SET(s.nulls_SEC_RANGE,SEC_RANGE), 0, 7 ) + IF( ST  IN SET(s.nulls_ST,ST), 0, 5 ) + IF( V_CITY_NAME  IN SET(s.nulls_V_CITY_NAME,V_CITY_NAME), 0, 11 ) + IF( ZIP  IN SET(s.nulls_ZIP,ZIP), 0, 13 ) + IF( PHONE  IN SET(s.nulls_PHONE,PHONE), 0, 20 ) + IF( FAX  IN SET(s.nulls_FAX,FAX), 0, 20 ) + IF( TAXONOMY  IN SET(s.nulls_TAXONOMY,TAXONOMY), 0, 7 ) + IF( TAXONOMY_CODE  IN SET(s.nulls_TAXONOMY_CODE,TAXONOMY_CODE), 0, 4 ) + IF( MEDICAID_NUMBER  IN SET(s.nulls_MEDICAID_NUMBER,MEDICAID_NUMBER), 0, 22 ) + IF( VENDOR_ID  IN SET(s.nulls_VENDOR_ID,VENDOR_ID), 0, 21 ) >= Config.BasicMatchThreshold); // Potentially remove anything that would violate FORCE(+) constraints
  MatchCands := JOIN(h00_match,Specificities(ih).ClusterSizes(InCluster=1),LEFT.LNPID=RIGHT.LNPID,TRANSFORM(LEFT),LOCAL); // Singletons only may match
  Rec := RECORD
    SALT30.UIDType LNPID1;
    SALT30.UIDType LNPID2;
  END;
// It is important that this is an EQUIVALENCE relationship - it allows us to form an implicit transitive closure
  h01 := SORT(h00_match,NPI_NUMBER,DEA_NUMBER,CLIA_NUMBER,MEDICARE_FACILITY_NUMBER,NCPDP_NUMBER,TAX_ID,FEIN,C_LIC_NBR,CNP_NAME,CNP_NUMBER,CNP_STORE_NUMBER,CNP_BTYPE,PRIM_RANGE,PRIM_NAME,SEC_RANGE,ST,V_CITY_NAME,ZIP,PHONE,FAX,TAXONOMY,TAXONOMY_CODE,MEDICAID_NUMBER,VENDOR_ID,LNPID);
  h02 := DEDUP(h01,NPI_NUMBER,DEA_NUMBER,CLIA_NUMBER,MEDICARE_FACILITY_NUMBER,NCPDP_NUMBER,TAX_ID,FEIN,C_LIC_NBR,CNP_NAME,CNP_NUMBER,CNP_STORE_NUMBER,CNP_BTYPE,PRIM_RANGE,PRIM_NAME,SEC_RANGE,ST,V_CITY_NAME,ZIP,PHONE,FAX,TAXONOMY,TAXONOMY_CODE,MEDICAID_NUMBER,VENDOR_ID,LOCAL); // ,LOCAL ok - we don't need a perfect dedup - this is an optimization
  Match := JOIN(h02,MatchCands,LEFT.NPI_NUMBER = RIGHT.NPI_NUMBER AND LEFT.DEA_NUMBER = RIGHT.DEA_NUMBER AND LEFT.CLIA_NUMBER = RIGHT.CLIA_NUMBER AND LEFT.MEDICARE_FACILITY_NUMBER = RIGHT.MEDICARE_FACILITY_NUMBER AND LEFT.NCPDP_NUMBER = RIGHT.NCPDP_NUMBER
       AND LEFT.TAX_ID = RIGHT.TAX_ID AND LEFT.FEIN = RIGHT.FEIN AND LEFT.C_LIC_NBR = RIGHT.C_LIC_NBR AND LEFT.LIC_STATE = RIGHT.LIC_STATE AND LEFT.CNP_NAME = RIGHT.CNP_NAME AND LEFT.CNP_NUMBER = RIGHT.CNP_NUMBER
       AND LEFT.CNP_STORE_NUMBER = RIGHT.CNP_STORE_NUMBER AND LEFT.CNP_BTYPE = RIGHT.CNP_BTYPE AND LEFT.PRIM_RANGE = RIGHT.PRIM_RANGE AND LEFT.PRIM_NAME = RIGHT.PRIM_NAME AND LEFT.SEC_RANGE = RIGHT.SEC_RANGE
       AND LEFT.ST = RIGHT.ST AND LEFT.V_CITY_NAME = RIGHT.V_CITY_NAME AND LEFT.ST = RIGHT.ST AND LEFT.ZIP = RIGHT.ZIP AND LEFT.PHONE = RIGHT.PHONE AND LEFT.CNP_NAME = RIGHT.CNP_NAME AND LEFT.FAX = RIGHT.FAX AND LEFT.CNP_NAME = RIGHT.CNP_NAME
       AND LEFT.TAXONOMY = RIGHT.TAXONOMY AND LEFT.TAXONOMY_CODE = RIGHT.TAXONOMY_CODE AND LEFT.MEDICAID_NUMBER = RIGHT.MEDICAID_NUMBER AND LEFT.VENDOR_ID = RIGHT.VENDOR_ID AND LEFT.SRC = RIGHT.SRC AND LEFT.LNPID < RIGHT.LNPID,TRANSFORM(Rec,SELF.LNPID2 := LEFT.LNPID,SELF.LNPID1 := RIGHT.LNPID), HASH);

  // h00_NPI   := h00(NPI_NUMBER NOT IN SET(s.nulls_NPI_NUMBER,NPI_NUMBER),SRC = 'NP');
  // h00_DEA   := h00(DEA_NUMBER NOT IN SET(s.nulls_DEA_NUMBER,DEA_NUMBER), SRC = 'DA');
  // h00_CLIA  := h00(CLIA_NUMBER NOT IN SET(s.nulls_CLIA_NUMBER,CLIA_NUMBER), SRC = 'QR');
  // h00_NCPDP := h00(NCPDP_NUMBER NOT IN SET(s.nulls_NCPDP_NUMBER,NCPDP_NUMBER), SRC = 'J2');
				
  // ForcedMatch0 := JOIN(h00_NPI,h00_NPI,LEFT.LNPID < RIGHT.LNPID AND LEFT.NPI_NUMBER = RIGHT.NPI_NUMBER,TRANSFORM(Rec,SELF.LNPID2 := LEFT.LNPID,SELF.LNPID1 := RIGHT.LNPID));
  // ForcedMatch1 := JOIN(h00_DEA,h00_DEA,LEFT.LNPID < RIGHT.LNPID AND LEFT.DEA_NUMBER = RIGHT.DEA_NUMBER,TRANSFORM(Rec,SELF.LNPID2 := LEFT.LNPID,SELF.LNPID1 := RIGHT.LNPID));
  // ForcedMatch2 := JOIN(h00_CLIA,h00_CLIA,LEFT.LNPID < RIGHT.LNPID AND LEFT.CLIA_NUMBER = RIGHT.CLIA_NUMBER,TRANSFORM(Rec,SELF.LNPID2 := LEFT.LNPID,SELF.LNPID1 := RIGHT.LNPID));
  // ForcedMatch3 := JOIN(h00_NCPDP,h00_NCPDP,LEFT.LNPID < RIGHT.LNPID AND LEFT.NCPDP_NUMBER = RIGHT.NCPDP_NUMBER,TRANSFORM(Rec,SELF.LNPID2 := LEFT.LNPID,SELF.LNPID1 := RIGHT.LNPID));

  // ForcedMatch := ForcedMatch0; //+ForcedMatch1+ForcedMatch2+ForcedMatch3;
  WithForcedMatch0 := Match;
  SALT30.MAC_Transitive_Closure(WithForcedMatch0, LNPID1, LNPID2, WithForcedMatch);
SHARED PickOne := DEDUP( SORT( DISTRIBUTE( WithForcedMatch,HASH(LNPID1) ), LNPID1, LNPID2, LOCAL), LNPID1, LOCAL); // Lowest collector ID for each singleton
EXPORT patch_file := PickOne;
  ut.MAC_Patch_Id(h00,LNPID,PickOne,LNPID1,LNPID2,o1); // Patch the input file
EXPORT input_file := o1 : INDEPENDENT;
EXPORT basic_match_count := COUNT(PickOne);
EXPORT id_delta := COUNT(DEDUP(h00,LNPID,ALL))-COUNT(DEDUP(input_file,LNPID,ALL)); // Should equal basic_match_count
END;
