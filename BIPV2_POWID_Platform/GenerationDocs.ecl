Generated by SALT V3.2.0
Command line options: -MBIPV2_POWID_Platform -eC:\Users\bentlela\AppData\Local\Temp\TFR514B.tmp 
File being processed :-
OPTIONS:-gh -ga -p2 -gs2
MODULE:BIPV2_POWID_Platform
FILENAME:POWID
 
// ------------------------------------
//  IDs and Tuning
// ------------------------------------
IDFIELD:EXISTS:POWID
RIDFIELD:rcid
RECORDS:4816645228
POPULATION:288596120
NINES:3
BLOCKTHRESHOLD:5
// THRESHOLD:42
 
IDPARENTS:OrgID,UltID
// IDCHILDREN:ProxID,DotID
HACK:NO_PARALLEL_MATCH
HACK:MULTIPARENT
HACK:NOSLICE
 
// ------------------------------------
//  Field validation/cleaning
// ------------------------------------
FIELDTYPE:multiword:CAPS:ALLOW(ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):SPACES( <>{}[]-^=!+&,./):ONFAIL(CLEAN)
FIELDTYPE:number:ALLOW(0123456789)
FIELDTYPE:hasZip4:ALLOW(0123456789):LENGTHS(4):ONFAIL(REJECT)
FIELDTYPE:RejectIfOverOne:ENUM(0|1):ONFAIL(REJECT)
FIELDTYPE:namesPerAddress:ENUM(0|1|2|3|4|5|6|7|8|9|10):ONFAIL(REJECT)
 
// ------------------------------------
//  Linking fields
// ------------------------------------
 
// residential v business
// # of inc biz @ address
// all biz name similar
// location
 
// if =1 inc biz @ addr & names are similar, then that's a POW
// if =0 inc biz 
 
// no more than 1 inc in clusters (is this still necessary?)
ATTRIBUTEFILE:charter:NAMED(_ds_attr_charter):VALUES(company_charter_number<company_inc_state):FORCE(--,ALL):IDFIELD(powid):26,1
 
// no more than 1 inc per address
FIELD:num_incs:LIKE(RejectIfOverOne):CARRY:0,0
FIELD:nodes_total:LIKE(RejectIfOverOne):CARRY:0,0
// FIELD:cnt_prox_per_lgid3:LIKE(RejectIfOverOne):CARRY:0,0
FIELD:RID_If_Big_Biz:FORCE(--):PROP:26,0
 
// no more than 10 legal names per address
FIELD:num_legal_names:LIKE(namesPerAddress):CARRY:0,0
 
// all biz name similar
FIELD:company_name:LIKE(multiword):BAGOFWORDS(MOST):EDIT1(2):PROP:FORCE(+):TYPE(string250):25,277
FIELD:cnp_name:LIKE(multiword):BAGOFWORDS(MANY):FORCE(+13):TYPE(string250):26,126
FIELD:cnp_number:PROP:FORCE(--):14,0
 
// skeletal address match, assert zip4 exists to ensure quality
FIELD:prim_range:FORCE:13,0
FIELD:prim_name:PROP:FORCE(+):15,0
FIELD:zip:LIKE(number):14,1
FIELD:zip4:LIKE(hasZip4):CARRY:0,0
 
// CARRY fields useful for evaluation
FIELD:sec_range:CARRY:0,0
FIELD:v_city_name:CARRY:0,0
FIELD:st:CARRY:0,0
FIELD:company_inc_state:CARRY:0,0
FIELD:company_charter_number:CARRY:0,0
FIELD:active_duns_number:CARRY:0,0
FIELD:hist_duns_number:CARRY:0,0
FIELD:active_domestic_corp_key:CARRY:0,0
FIELD:hist_domestic_corp_key:CARRY:0,0
FIELD:foreign_corp_key:CARRY:0,0
FIELD:unk_corp_key:CARRY:0,0
FIELD:company_fein:CARRY:0,0
FIELD:cnp_btype:CARRY:0,0
FIELD:company_name_type_derived:CARRY:0,0
FIELD:company_bdid:CARRY:0,0
// FIELD:nodes_total:CARRY:0,0
 
// ------------------------------------
//  Metadata
// ------------------------------------
FIELD:dt_first_seen:RECORDDATE(FIRST):0,0
FIELD:dt_last_seen:RECORDDATE(LAST):0,0
SOURCEFIELD:source:CONSISTENT(company_name,cnp_number,prim_range,prim_name,zip):PARTITION(BIPV2.Mod_Sources.src2partition)
 
Total available specificity:133
Recommended matching threshold 38
Search Threshold set at 20
Use of PERSISTs in code set at:2
 
______________________________English Description of Matching Process___________________________
 
A SALT generated matching process really only contains one single matching rule.
SALT compares every record to every possible matching record and then allocates a score to how well
the records match. SALT then pairs those clusters which have the highest match scores provided the scores
meet or exceed the matching threshold. The scoring process is highly sophisticated and detailed below
however it can essentially be thought of as allocating points for every pair of fields that match
and subtracting points for every pair of fields that do not match.
This process was told to produce 3 nines of accuracy on a population of 288596128 with  4816645120 records.
The matching threshold is therefore set at 38.
 
___Field by Field Breakdown of Scoring Method___
 
num_incs Scoring: This field is not used for scoring; rather it is carried along for context and debugging
nodes_total Scoring: This field is not used for scoring; rather it is carried along for context and debugging
RID_If_Big_Biz Scoring: In order for two records to be a match it is also required that the RID_If_Big_Biz fields not not match.
If a field is null and another record in the same cluster has a value for that field then the other records value will be used.
Two RID_If_Big_Biz fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the RID_If_Big_Biz
but should average 26 points with a failed match substracting 26 points.
(This subtraction estimate is based upon 0% of clusters with 2 or more records have 2 or more values for RID_If_Big_Biz.)
 
num_legal_names Scoring: This field is not used for scoring; rather it is carried along for context and debugging
company_name Scoring: In order for two records to be a match it is also required that the company_name fields match.
If a field is null and another record in the same cluster has a value for that field then the other records value will be used.
Two company_name fields will be considered to match if:
  - they are identical
  - one can be turned into the other with 1 edit (see Glossary)
  - if the space separated tokens in one match the other if re-arranged
The exact number of points allocated to a match will depend upon the global scarcity of the company_name
and the degree of fuzziness required but should average 25 points with a failed match substracting 18 points.
(This subtraction estimate is based upon 27% of clusters with 2 or more records have 2 or more values for company_name.)
 
cnp_name Scoring: In order for two records to be a match it is also required that the cnp_name fields match.
Specifically the score awarded to this field must be >= 13 .
Two cnp_name fields will be considered to match if:
  - they are identical
  - if the space separated tokens in one match the other if re-arranged
The exact number of points allocated to a match will depend upon the global scarcity of the cnp_name
and the degree of fuzziness required but should average 26 points with a failed match substracting 22 points.
(This subtraction estimate is based upon 12% of clusters with 2 or more records have 2 or more values for cnp_name.)
 
cnp_number Scoring: In order for two records to be a match it is also required that the cnp_number fields not not match.
If a field is null and another record in the same cluster has a value for that field then the other records value will be used.
Two cnp_number fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the cnp_number
but should average 14 points with a failed match substracting 14 points.
(This subtraction estimate is based upon 0% of clusters with 2 or more records have 2 or more values for cnp_number.)
 
prim_range Scoring: In order for two records to be a match it is also required that the prim_range fields match.
Two prim_range fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the prim_range
but should average 13 points with a failed match substracting 13 points.
(This subtraction estimate is based upon 0% of clusters with 2 or more records have 2 or more values for prim_range.)
 
prim_name Scoring: In order for two records to be a match it is also required that the prim_name fields match.
If a field is null and another record in the same cluster has a value for that field then the other records value will be used.
Two prim_name fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the prim_name
but should average 15 points with a failed match substracting 15 points.
(This subtraction estimate is based upon 0% of clusters with 2 or more records have 2 or more values for prim_name.)
 
zip Scoring: Two zip fields will be considered to match if:
  - they are identical
The exact number of points allocated to a match will depend upon the global scarcity of the zip
but should average 14 points with a failed match substracting 13 points.
(This subtraction estimate is based upon 0% of clusters with 2 or more records have 2 or more values for zip.)
 
zip4 Scoring: This field is not used for scoring; rather it is carried along for context and debugging
sec_range Scoring: This field is not used for scoring; rather it is carried along for context and debugging
v_city_name Scoring: This field is not used for scoring; rather it is carried along for context and debugging
st Scoring: This field is not used for scoring; rather it is carried along for context and debugging
company_inc_state Scoring: This field is not used for scoring; rather it is carried along for context and debugging
company_charter_number Scoring: This field is not used for scoring; rather it is carried along for context and debugging
active_duns_number Scoring: This field is not used for scoring; rather it is carried along for context and debugging
hist_duns_number Scoring: This field is not used for scoring; rather it is carried along for context and debugging
active_domestic_corp_key Scoring: This field is not used for scoring; rather it is carried along for context and debugging
hist_domestic_corp_key Scoring: This field is not used for scoring; rather it is carried along for context and debugging
foreign_corp_key Scoring: This field is not used for scoring; rather it is carried along for context and debugging
unk_corp_key Scoring: This field is not used for scoring; rather it is carried along for context and debugging
company_fein Scoring: This field is not used for scoring; rather it is carried along for context and debugging
cnp_btype Scoring: This field is not used for scoring; rather it is carried along for context and debugging
company_name_type_derived Scoring: This field is not used for scoring; rather it is carried along for context and debugging
company_bdid Scoring: This field is not used for scoring; rather it is carried along for context and debugging
dt_first_seen Scoring: Date fields are not presently used for scoring but are carried along for debugging purposes
dt_last_seen Scoring: Date fields are not presently used for scoring but are carried along for debugging purposes
 
_AttributeFile Scoring_
Scores from attribute files are attributed to every potential record match between two clusters
All the field scoring and force restrictions specified above still apply.
The scores noted below may be thought of as bonus points.
 
Additional Scoring for fields company_charter_number,company_inc_state from file charter:
 A score will be allocated for charter only in the event of an exact match, no penalty attaches to a no-match
The exact score will depend upon the global scarcity of charter but should average 26.
If multiple charter match for the same cluster pairing only the highest scoring 1 will apply.
Every attribute value must match to a value in the other attribute IF they have the same context
 
__Glossary__
Edit Distance: An edit distance of (say) one implies that one string can be converted into another by doing one of
  - Changing one character
  - Deleting one character
  - Transposing two characters
 
Forcing Criteria: In addition to the general 'best match' logic it is possible to insist that
one particular field must match to some degree or the whole record is considered a bad match.
The criterial applied to that one field is the forcing criteria.
 
Cascade: Best Type rules are applied in such a way that the rules are applied one by one UNTIL the first rule succeeds; subsequent rules are then skipped.
 
__General Notes__
How is it decided how much to subtract for a bad match?
SALT computes for each field the percentage likelihood that a valid cluster will have two or more values for a given field
this value (called the switch value in the SALT literature) is then used to produce the subtraction value from the match value.
The value in this document is the one typed into the SPC file; the code will use a value computed at run-time.
 
